#!/usr/bin/env python3
# Copyright (c) 2024 Embeint Inc
# SPDX-License-Identifier: Apache-2.0

import argparse
import sys
import os
import pickle

sys.path.insert(0, os.path.join(os.path.dirname(__file__), "python-devicetree", "src"))

from devicetree import edtlib


def parse_args():
    # Returns parsed command-line arguments
    parser = argparse.ArgumentParser(allow_abbrev=False)
    parser.add_argument(
        "--edt-pickle",
        required=True,
        help="path to read the pickled edtlib.EDT object from",
    )
    parser.add_argument("--header-out", required=True, help="path to write header to")

    return parser.parse_args()


def file_header(args):
    return f"""/*
 * Generated by gen_tfm_defines.py
 *
 * DTS pickle file:
 *   {args.edt_pickle}
 */
"""


class TFMDefine:
    def __init__(self, name, value, size=False):
        self.name = name
        self.value = value
        self.size = size

    def __str__(self):
        if isinstance(self.value, int):
            val = f"0x{self.value:08x}"
            if self.size:
                val += f" /* {self.value // 1024}kB */"
        else:
            val = self.value
        return f"#define {self.name:<40s} {val}"


def common_defines(tfm):
    sram = tfm["sram"].val
    sram_s = tfm["sram-secure"].val
    sram_ns = tfm["sram-nonsecure"].val

    return {
        sram.path: [
            TFMDefine("SRAM_BASE_ADDRESS", sram.regs[0].addr),
            TFMDefine("TOTAL_RAM_SIZE", sram.regs[0].size, True),
        ],
        sram_s.path: [
            TFMDefine("S_DATA_START", sram_s.regs[0].addr),
            TFMDefine("S_DATA_SIZE", sram_s.regs[0].size, True),
            TFMDefine("S_DATA_LIMIT", sram_s.regs[0].addr + sram_s.regs[0].size - 1),
        ],
        sram_ns.path: [
            TFMDefine("NS_DATA_START", sram_ns.regs[0].addr),
            TFMDefine("NS_DATA_SIZE", sram_ns.regs[0].size, True),
            TFMDefine("NS_DATA_LIMIT", sram_ns.regs[0].addr + sram_ns.regs[0].size - 1),
        ],
        "System Protection Unit": [
            TFMDefine("SPU_FLASH_REGION_SIZE", tfm["spu-flash-region-size"].val, True),
            TFMDefine("SPU_SRAM_REGION_SIZE", tfm["spu-sram-region-size"].val, True),
        ],
    }


def flash_device_defines(index, device):
    prefix = device.props["define-prefix"].val
    complete = device.props["complete"].val

    # Defer to size property (in bits) if it exists
    if "size" in complete.props:
        complete_size = complete.props["size"].val // 8
    else:
        complete_size = complete.regs[0].size
    # Optional override of the sector size
    if "erase-block-size" in device.props:
        erase_size = device.props["erase-block-size"].val
    else:
        erase_size = complete.props["erase-block-size"].val
    if "write-block-size" in device.props:
        write_size = device.props["write-block-size"].val
    else:
        write_size = complete.props["write-block-size"].val

    defines = {
        complete.path: [
            TFMDefine(f"{prefix}FLASH_DRIVER", device.props["driver"].val),
            TFMDefine(f"{prefix}FLASH_DRIVER_ID", f"(FLASH_DEVICE_ID + {index})"),
            TFMDefine(f"{prefix}FLASH_BASE_ADDRESS", complete.regs[0].addr),
            TFMDefine(f"{prefix}FLASH_TOTAL_SIZE", complete_size, True),
            TFMDefine(f"{prefix}FLASH_AREA_IMAGE_SECTOR_SIZE", erase_size, True),
            TFMDefine(f"{prefix}FLASH_AREA_IMAGE_WRITE_SIZE", write_size),
        ],
    }
    if "extra-defines" in device.props:
        for extra in device.props["extra-defines"].val:
            defines[complete.path].append(TFMDefine(*extra.split("=")))

    if "img-bl2" in device.props:
        flash_bl2 = device.props["img-bl2"].val
        defines[flash_bl2.path] = [
            TFMDefine("FLASH_AREA_BL2_OFFSET", flash_bl2.regs[0].addr),
            TFMDefine("FLASH_AREA_BL2_SIZE", flash_bl2.regs[0].size, True),
            TFMDefine("FLASH_DEV_NAME", f"{prefix}FLASH_DRIVER"),
            TFMDefine(
                "TFM_HAL_FLASH_PROGRAM_UNIT", f"{prefix}FLASH_AREA_IMAGE_WRITE_SIZE"
            ),
        ]

    if "img-primary-secure" in device.props:
        flash_s = device.props["img-primary-secure"].val
        defines[flash_s.path] = [
            TFMDefine("FLASH_S_PARTITION_OFFSET", flash_s.regs[0].addr),
            TFMDefine("FLASH_S_PARTITION_SIZE", flash_s.regs[0].size, True),
            TFMDefine("FLASH_DEV_NAME_0", f"{prefix}FLASH_DRIVER"),
            TFMDefine("FLASH_DEVICE_ID_0", f"{prefix}FLASH_DRIVER_ID"),
        ]

    if "img-primary-nonsecure" in device.props:
        flash_ns = device.props["img-primary-nonsecure"].val
        defines[flash_ns.path] = [
            TFMDefine("FLASH_NS_PARTITION_OFFSET", flash_ns.regs[0].addr),
            TFMDefine("FLASH_NS_PARTITION_SIZE", flash_ns.regs[0].size, True),
            TFMDefine("FLASH_NS_DEV_NAME", f"{prefix}FLASH_DRIVER"),
            TFMDefine("FLASH_DEV_NAME_1", f"{prefix}FLASH_DRIVER"),
            TFMDefine("FLASH_DEVICE_ID_1", f"{prefix}FLASH_DRIVER_ID"),
        ]

    if "img-secondary-secure" in device.props:
        flash_s = device.props["img-secondary-secure"].val
        defines[flash_s.path] = [
            TFMDefine("FLASH_S1_S_PARTITION_OFFSET", flash_s.regs[0].addr),
            TFMDefine("FLASH_S1_S_PARTITION_SIZE", flash_s.regs[0].size, True),
            TFMDefine("FLASH_S1_S_DEV_NAME", f"{prefix}FLASH_DRIVER"),
            TFMDefine("FLASH_DEV_NAME_2", f"{prefix}FLASH_DRIVER"),
            TFMDefine("FLASH_DEVICE_ID_2", f"{prefix}FLASH_DRIVER_ID"),
        ]

    if "img-secondary-nonsecure" in device.props:
        flash_ns = device.props["img-secondary-nonsecure"].val
        defines[flash_ns.path] = [
            TFMDefine("FLASH_S1_NS_PARTITION_OFFSET", flash_ns.regs[0].addr),
            TFMDefine("FLASH_S1_NS_PARTITION_SIZE", flash_ns.regs[0].size, True),
            TFMDefine("FLASH_S1_NS_DEV_NAME", f"{prefix}FLASH_DRIVER"),
            TFMDefine("FLASH_DEV_NAME_3", f"{prefix}FLASH_DRIVER"),
            TFMDefine("FLASH_DEVICE_ID_3", f"{prefix}FLASH_DRIVER_ID"),
        ]

    if "partition-ps" in device.props:
        flash_ps = device.props["partition-ps"].val
        defines[flash_ps.path] = [
            TFMDefine("TFM_HAL_PS_FLASH_DRIVER", f"{prefix}FLASH_DRIVER"),
            TFMDefine(
                "TFM_HAL_PS_PROGRAM_UNIT", f"{prefix}FLASH_AREA_IMAGE_WRITE_SIZE"
            ),
            TFMDefine("TFM_HAL_PS_SECTORS_PER_BLOCK", 1),
            TFMDefine("FLASH_PS_AREA_OFFSET", flash_ps.regs[0].addr),
            TFMDefine("FLASH_PS_AREA_SIZE", flash_ps.regs[0].size, True),
        ]

    if "partition-its" in device.props:
        flash_its = device.props["partition-its"].val
        defines[flash_its.path] = [
            TFMDefine("TFM_HAL_ITS_FLASH_DRIVER", f"{prefix}FLASH_DRIVER"),
            TFMDefine(
                "TFM_HAL_ITS_PROGRAM_UNIT", f"{prefix}FLASH_AREA_IMAGE_WRITE_SIZE"
            ),
            TFMDefine("TFM_HAL_ITS_SECTORS_PER_BLOCK", 1),
            TFMDefine("FLASH_ITS_AREA_OFFSET", flash_its.regs[0].addr),
            TFMDefine("FLASH_ITS_AREA_SIZE", flash_its.regs[0].size, True),
        ]

    if "partition-otp" in device.props:
        flash_otp = device.props["partition-otp"].val
        defines[flash_otp.path] = [
            TFMDefine("TFM_HAL_OTP_FLASH_DRIVER", f"{prefix}FLASH_DRIVER"),
            TFMDefine("TFM_HAL_OTP_SECTORS_PER_BLOCK", 1),
            TFMDefine("FLASH_OTP_NV_COUNTERS_AREA_OFFSET", flash_otp.regs[0].addr),
            TFMDefine("FLASH_OTP_NV_COUNTERS_AREA_SIZE", flash_otp.regs[0].size, True),
            TFMDefine(
                "FLASH_OTP_NV_COUNTERS_SECTOR_SIZE",
                f"{prefix}FLASH_AREA_IMAGE_SECTOR_SIZE",
            ),
        ]

    if "partition-nonsecure-storage" in device.props:
        flash_ns_storage = device.props["partition-nonsecure-storage"].val
        defines[flash_ns_storage.path] = [
            TFMDefine(
                "NRF_FLASH_NS_STORAGE_AREA_OFFSET", flash_ns_storage.regs[0].addr
            ),
            TFMDefine(
                "NRF_FLASH_NS_STORAGE_AREA_SIZE", flash_ns_storage.regs[0].size, True
            ),
        ]
    return defines


def define_gen(mapping):
    content = ""
    for node, defines in mapping.items():
        content += "\n"
        content += f"/* {node} */\n"
        content += "\n".join([str(d) for d in defines])
        content += "\n"
    return content


def validate_partitions(tfm_config):
    def nodes_overlap(a, b):
        return bool(max(0, min(a[1], b[1]) - max(a[0], b[0])))

    err = ""
    # Validate that primary image does not overlap storage regions
    for flash_dev in tfm_config.children.values():
        if "img-primary-secure" not in flash_dev.props:
            continue

        bl2 = flash_dev.props["img-bl2"].val
        s = flash_dev.props["img-primary-secure"].val
        ns = flash_dev.props["img-primary-nonsecure"].val
        bl2_interval = [bl2.regs[0].addr, bl2.regs[0].addr + bl2.regs[0].size - 1]
        s_interval = [s.regs[0].addr, s.regs[0].addr + s.regs[0].size - 1]
        ns_interval = [ns.regs[0].addr, ns.regs[0].addr + ns.regs[0].size - 1]

        if nodes_overlap(bl2_interval, s_interval):
            err += "'img-bl2' and 'img-primary-secure' overlap!\n"
            err += f"\t(0x{bl2_interval[0]:x}-0x{bl2_interval[1]:x}) (0x{s_interval[0]:x}-0x{s_interval[1]:x})\n"
        if nodes_overlap(s_interval, ns_interval):
            err += "'img-primary-secure' and 'img-primary-nonsecure' overlap!\n"
            err += f"\t(0x{s_interval[0]:x}-0x{s_interval[1]:x}) (0x{p_interval[0]:x}-0x{p_interval[1]:x})\n"

        partitions_to_check = [
            "partition-ps",
            "partition-its",
            "partition-otp",
            "partition-nonsecure-storage",
        ]
        for partition in partitions_to_check:
            if partition not in flash_dev.props:
                continue
            p = flash_dev.props[partition].val
            p_interval = [p.regs[0].addr, p.regs[0].addr + p.regs[0].size - 1]

            if nodes_overlap(bl2_interval, p_interval):
                err += f"'img-bl2' and '{partition}' overlap!\n"
                err += f"\t(0x{bl2_interval[0]:x}-0x{bl2_interval[1]:x}) (0x{p_interval[0]:x}-0x{p_interval[1]:x})\n"
            if nodes_overlap(s_interval, p_interval):
                err += f"'img-primary-secure' and '{partition}' overlap!\n"
                err += f"\t(0x{s_interval[0]:x}-0x{s_interval[1]:x}) (0x{p_interval[0]:x}-0x{p_interval[1]:x})\n"
            if nodes_overlap(ns_interval, p_interval):
                err += f"'img-primary-nonsecure' and '{partition}' overlap!\n"
                err += f"\t(0x{ns_interval[0]:x}-0x{ns_interval[1]:x}) (0x{p_interval[0]:x}-0x{p_interval[1]:x})\n"

    if err != "":
        sys.exit(err)


def main():
    args = parse_args()
    tfm_compat = "arm,trusted-firmware-m"

    with open(args.edt_pickle, "rb") as f:
        edt = pickle.load(f)

    tfm = edt.compat2nodes[tfm_compat]

    content = file_header(args)
    if len(tfm) == 1:
        validate_partitions(tfm[0])
        content += define_gen(common_defines(tfm[0].props))
        for idx, flash_dev in enumerate(tfm[0].children.values()):
            content += define_gen(flash_device_defines(idx, flash_dev))
    else:
        # Silent failure for boards that don't support devicetree defines
        content += (
            f"""\n#error Expected exactly one node with compat `{tfm_compat}`\n"""
        )

    with open(args.header_out, "w", encoding="utf-8") as f:
        f.write(content)


if __name__ == "__main__":
    main()
